#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.

# packages! -------
library(shiny)
library(tidyverse)
library(readxl)
# graphing/map stuff
library(viridis)
library(sf)
library(gridExtra)
library(pointdexter)
# to download pointdexter^ type remotes::install_github("cenuno/pointdexter") in your console
  #install the remotes package first

# load data -----
title_dat <- read_csv("data/CommAreas.csv")
# map data from Chicago Data Portal 
communities <- read_sf('data/communities/geo_export_45d4da8d-3fc8-4ccb-9b0c-8f546d526c9a.shp')

bike_routes <- read_sf('data/bikes/geo_export_02f6b9aa-6d14-4951-9963-31aeaa95c2b8.shp')

# changing communities ID variable so it can be joined with crimes
communities <- communities %>% 
  mutate(area_numbe = as.numeric(area_numbe))

# census data for crimes
census <- read_excel('data/neighborhood_info.xlsx')
# adjusting census data so it can be joined
census <- census %>% 
  mutate(neighborhood = tolower(neighborhood)) %>% 
  rename(community = neighborhood)

# ----------------------------

# crash data
crash_dat <- read_csv("data/2021_crash_communities.csv") %>% 
  mutate(
    community = str_to_title(community),
    community = ifelse(community == "Ohare", "O'Hare", community),
    community = ifelse(community == "Mckinley Park", "McKinley Park", community),
    `Community Area Number` = NA
  ) %>% 
  rename("Crash Count" = "n") %>% 
  rename("Community" = "community") %>% 
  filter(!is.na(Community))

for (i in 1:77) {
  for (j in 1:77) {
    if (crash_dat$Community[i] == title_dat$name[j]) {
      crash_dat$`Community Area Number`[i] = title_dat$number[j]
    }
  }
}
crash_dat <- crash_dat %>% 
  arrange(`Community Area Number`)


# crimes data - relevant
relevant_crimes <- read_csv("data/crimes_2013-2021/relevant_crimes.csv")

relevant_crimes_i <- relevant_crimes %>% 
  mutate(community = NA) %>% 
  group_by(community_area, community, year) %>% 
  select(-location_description) %>% 
  count() %>% 
  filter(!is.na(community_area))

# add community names
for (i in 1:693) {
  for (j in 1:77) {
    if (relevant_crimes_i$community_area[i] == title_dat$number[j]) {
      relevant_crimes_i$community[i] = title_dat$name[j]
    }
  }
}

# summing total crime statistics yearly
all_chicago <- relevant_crimes %>% 
  mutate(community = "All - Chicago") %>% 
  group_by(year, community) %>% 
  count()
relevant_crimes_i <- relevant_crimes_i %>% rbind(all_chicago)

# creating labels for UI
community_labs <- relevant_crimes_i$community

# counting crimes
crimes_count <- relevant_crimes %>% 
  group_by(community_area) %>% 
  summarise(num_crimes = n()) %>% 
  left_join(communities, by = c('community_area' = 'area_numbe'))

# census data for crimes
crimes_count <- crimes_count %>% 
  mutate(community = tolower(community))

# finding crime rate and other statistics
crimes_census <- crimes_count %>% 
  left_join(census)
crimes_census <- crimes_census %>% 
  mutate(crime_rate = (num_crimes / pop) * 100000,
         divvy_to_pop = (num_of_divvy_stations / pop) * 100000,
         divvy_to_area = num_of_divvy_stations / area_sq_mi)

# finding the center of each community for geom_point
crimes_census <- crimes_census %>% 
  mutate(geometry_center = st_centroid(geometry))
crimes_census <- crimes_census %>% 
  mutate(lat_lon = st_coordinates(geometry_center),
         lat = lat_lon[,"X"],
         long = lat_lon[,"Y"])

#--------------------------------

# police sentiment
sentiment_dat <- read_csv("data/sentiment_eda.csv") %>% 
  mutate(comm_number = 1:77) %>% 
  arrange(comm_number)

#--------------------------------

# nations_2021 <- read_csv('data/gang_data/2021_Gang_Boundaries_and_nations.csv')
# # read in all gang nations
# nations <- read_csv('data/gang_data/Gang_nations.csv') %>% 
#   mutate(nation = factor(nation, levels = c('People','Folks','None')))
# # communities
# chicago_community <- st_read(
#   'data/gang_data/Boundaries - Community Areas (current)/geo_export_2099592d-f4d8-46cf-9881-dd554256e0fd.shp'
# )
# # community boundaries
# data("community_areas_spdf")
# # create list of coordinate pair matrices for each community area ----
# community.area.boundaries <-
#   GetPolygonBoundaries(my.polygon = community_areas_spdf, 
#                        labels = community_areas_spdf$community)
# # gang boundaries
# gang_boundary_2021 <- 
#   st_read(
#     "data/gang_data/2021_Gang_Boundaries/2021_Gang_Boundaries.shp") %>% 
#   left_join(nations %>% 
#               dplyr::select(GANG_NAME, nation) %>% 
#               mutate(nation = factor(nation, levels = c('People','Folks','None'))), 
#             by = 'GANG_NAME') %>% 
#   st_cast("POLYGON") %>% 
#   st_transform(4326) %>% 
#   mutate(
#     # find the centroid of each gang territory
#     centroid = st_centroid(.)$geometry,
#     # get the latitude and longitude for centroids
#     centroid_lng = st_coordinates(centroid)[,1],
#     centroid_lat = st_coordinates(centroid)[,2],
#     # find the corresponding community
#     community = LabelPointsWithinPolygons(lat = centroid_lat,
#                                           lng = centroid_lng,
#                                           polygon.boundaries = community.area.boundaries))
# # get 2007-2021 data
# gang_bound <- function(yr){
#   gang_boundary <- st_read(
#     paste0("data/gang_data/", yr, "_Gang_Boundaries/", yr, "_Gang_Boundaries.shp")) %>% 
#     mutate(year = yr)
#   # merge with 
#   gang_boundary <- gang_boundary %>% 
#     left_join(nations %>% 
#                 dplyr::select(GANG_NAME, nation) %>% 
#                 mutate(nation = factor(nation, levels = c('People','Folks','None'))), 
#               by = 'GANG_NAME') %>% 
#     st_cast("POLYGON") %>% 
#     st_transform(4326) %>% 
#     mutate(
#       # find the centroid of each gang territory
#       centroid = st_centroid(.)$geometry,
#       # get the latitude and longitude for centroids
#       centroid_lng = st_coordinates(centroid)[,1],
#       centroid_lat = st_coordinates(centroid)[,2],
#       # find the corresponding community
#       community = LabelPointsWithinPolygons(lat = centroid_lat,
#                                             lng = centroid_lng,
#                                             polygon.boundaries = community.area.boundaries))
#   names(gang_boundary) <- c("OBJECTID", "GANG_NAME", "Shape__Are", "Shape__Len", "year", 'nation', "geometry","centroid",
#                             "centroid_lng", "centroid_lat", "community")
#   return(gang_boundary)
# }
# 
# gang_boundary_2007_2019 <- gang_boundary_2021 %>% 
#   mutate(year = 2021) %>% 
#   dplyr::select(OBJECTID, GANG_NAME, Shape__Are, Shape__Len, year, nation, geometry, centroid, centroid_lng, centroid_lat, community)
# for (x in c('2007','2008','2009','2010','2011','2012','2014','2015','2016','2017','2018','2019')) {
#   gang_boundary_2007_2019 <- rbind(gang_boundary_2007_2019, gang_bound(x))
# }
# 
# # year choices for UI
# year_choices <- c(2007:2021)
# year_choices <- year_choices[-c(7,14)]

# Define UI for application that draws a histogram -----
ui <- fluidPage(
  
    # App title ----
    titlePanel("Crime Cases in Chicago Over Time"),

    # Sidebar with a slider input for number of bins 
    sidebarLayout(position = "right",
        sidebarPanel(
          # crimes input
          p("The following lineplot shows the total number of outdoor/vehicle-related
            crimes for each year from 2013-2021."),
          selectInput(inputId = "community_input", 
                      label = "Select Community:",
                      choices = as.list(community_labs),
                      selected = community_labs[78]),
          p("Crime rate is defined as the number of crimes per 100,000 people. 
          As usual, we see that there are more bike lanes in areas with low crime 
          rates. Divvy to population rate is defined (by me) as the number of Divvy
          stations per 100,000 people. Divvy to area rate is the number of Divvy stations 
          divided by the area in square miles. The Divvy to population map doesn't yield
          much correlation, but the Divvy per area reveals a lower Divvy per area rate in 
          southern neighborhoods with more crimes."),
          # crimerate input
          radioButtons(inputId = "crimerate_input", 
                      label = "Select Measure:",
                      choices = as.list(c("divvy_to_area",
                                  "divvy_to_pop")),
                      selected = "divvy_to_area"),
          # police sentiment
          p("Chicago Police Sentiment (2017-2021)"),
          p("Data can be found in the Chicago Data Portal. It is updated monthly and the data 
            owner is the Chicago Police Department, categorized under ‘Public Safety’. 
            Sorted by the 77 communities, this data is aggregated by year. 
            Each column gives either a trust or safety score for a demographic group, 
            or the average score across the entire community. The demographic categories 
            include age, sex, race, education, and income level. "),
          radioButtons("fill", 
                       label = "Select Trust or Safety Score for Fill",
                       choices = list("Trust Score", 
                                      "Safety Score"),
                       selected = "Trust Score"),
          p("Data for gang boundaries are obtained from the Police 
            Department GIS Data as part of the  Chicago Police Department
            CLEARMap database, provided by the Office of Public Safety Administration (OPSA). 
            The data are updated annually. Available in the dataset are the data from 2007 to 
            2021, except for 2013 and 2020. Alliance of each gang (people or folks nation) 
            can be found here. Chicago gang boundary data mapped to each community for 2007 
            to 2021 (except for 2013 and 2020)"),
          # gang input
          # selectInput(inputId = "gang_year", 
          #             label = "Select Year:",
          #             choices = as.list(year_choices),
          #             selected = "2021"),
          # checkboxGroupInput("gang_nation", 
          #              label = "Select Nation to Display",
          #              choices = list("People", 
          #                             "Folks",
          #                             "None"),
          #              selected = list("People", 
          #                              "Folks",
          #                              "None")),
          # crashes input
        ),

        # Show a plot of the generated distribution
        mainPanel(
           plotOutput("crimes_timeline"),
           plotOutput("crimerate_map"),
           plotOutput("trust_safety_plot"),
           plotOutput("gangs_plots"),
           plotOutput("crashes_plot")
        )
    )
)

# Define server logic required to draw timeline/map -----
server <- function(input, output) {

    output$crimes_timeline <- renderPlot({
     
      # user-supplied community area
      community_crimes <- relevant_crimes_i %>% 
        filter(community == input$community_input)
    
      # building timeline plot
      community_crimes %>% 
        ggplot(aes(x = year, y = n)) +
          geom_line(color = "black", size = 1) +
          geom_point(size = 4) +
          labs(
          x = "Year",
          y = "Crimes"
          )  +
          theme_minimal() +
          scale_x_continuous(breaks = seq(2013, 2021, 1))
      
    })
    
    output$crimerate_map <- renderPlot({
      
      # user-supplied input
      pop_or_area <- case_when(
        input$crimerate_input == "divvy_to_area" ~ pull(crimes_census, divvy_to_area),
        input$crimerate_input == "divvy_to_pop" ~ pull(crimes_census, divvy_to_pop),
      )
      
      crimes_census %>% 
            ggplot() +
            geom_sf(mapping = aes(geometry = geometry, fill = pop_or_area)) +
            geom_sf(data = bike_routes) +
            geom_point(mapping = aes(x = lat, y = long, size = crime_rate), 
                       color = "red", alpha = 0.5) +
            theme_void() +
            scale_fill_viridis()
      
    })
    
    # police sentiment plot
    output$trust_safety_plot <- renderPlot({
      
      # variable for fill
      fill_var <- switch(input$fill,
                         "Trust Score" = sentiment_dat$trust, 
                         "Safety Score" = sentiment_dat$safety
                         )
      
      # creating the map
      crimes_census %>% 
        filter(community != "All - Chicago") %>% 
        ggplot() +
        geom_sf(mapping = aes(geometry = geometry, fill = fill_var)) +
        theme_void() +
        scale_fill_viridis()
      
    })
    
    # # gang data
    # output$gangs_plots <- renderPlot({
    #   
    #   # chicago plot
    #   # ggplot() + 
    #   #   geom_sf(data = chicago_community) + 
    #   #   ggtitle("Chicago Boundary Plot (Community)") + 
    #   #   coord_sf() +
    #   #   theme_minimal()
    # # turn off the s2 processing
    # sf::sf_use_s2(FALSE)
    # 
    # # select year for plot
    #   year_select <- input$gang_year
    #   given_nation <- input$gang_nation
    # 
    # ggplot() + 
    #   geom_sf(data = chicago_community,
    #           color = 'gray') + 
    #   geom_sf(data = gang_boundary_2007_2019 %>% filter(year==year_select) %>% filter(nation %in% given_nation), 
    #           aes(fill = nation,
    #               color = nation),
    #           alpha = 0.8) + 
    #   coord_sf() +
    #   theme_minimal() +
    #   theme(text = element_text(size = 20))  
    # 
    # })
    # 
    # output$crashes_plot <- renderPlot({
    #   
    #   crimes_census %>% 
    #     filter(community != "All - Chicago") %>% 
    #   ggplot() + 
    #     geom_sf(mapping = aes(geometry = geometry,
    #                           fill = crash_dat$`Crash Count`),
    #             color = 'gray') +
    #     coord_sf() +
    #     theme_minimal() +
    #     scale_fill_viridis()
    #     
    #   
    # })
    
      
}

# Run the application ------
shinyApp(ui = ui, server = server)
